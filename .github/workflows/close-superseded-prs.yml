---
# Reusable workflow to automatically close PRs that have been superseded.
name: Close Superseded PRs

on:
  workflow_call:
    inputs:
      superseded_label:
        description: Label to apply to superseded pull requests. Leave blank to skip.
        required: false
        default: superseded
        type: string
      keywords:
        description: Comma-separated keywords to detect superseded PRs. Leave blank to use defaults.
        required: false
        default: ""
        type: string
      mark_duplicate_comment:
        description: Add a "Duplicate of #<new PR>" comment to superseded PRs.
        required: false
        default: "false"
        type: string
      comment_template_path:
        description: Path to a comment template file in the caller repo. Leave blank to use the default comment.
        required: false
        default: ""
        type: string
      comment_footer:
        description: Footer text appended to the auto-comment. Leave blank to omit.
        required: false
        default: This comment was added automatically by the close-superseded-prs workflow.
        type: string

permissions:
  pull-requests: write
  issues: write

jobs:
  close-superseded:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: Parse superseded PRs from description
        id: parse
        uses: actions/github-script@v7
        env:
          KEYWORDS: ${{ inputs.keywords }}
        with:
          script: |
            const DEFAULT_KEYWORDS = [
              "supersedes",
              "superseded",
              "supercedes",
              "superceded",
              "replaces",
              "replaced",
            ];
            const keywordInput = (process.env.KEYWORDS || '').trim();
            const keywords = keywordInput
              ? keywordInput.split(',').map(k => k.trim()).filter(Boolean)
              : DEFAULT_KEYWORDS;

            const escapeRegex = (value) => value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            const keywordPattern = keywords.map(escapeRegex).join('|');
            const regex = new RegExp(
              `\\b(?:${keywordPattern})\\b(?:\\s+by)?:?\\s*#(\\d+)`,
              'gi',
            );

            const body = context.payload.pull_request.body || '';
            const newPrNumber = context.payload.pull_request.number;
            const newPrTitle = context.payload.pull_request.title;
            const newPrUrl = context.payload.pull_request.html_url;

            // Match patterns (defaults; configurable via keywords input):
            // - "supercedes #123", "supersedes #123", "SUPERCEDES #123"
            // - "superseded by #123", "superceded by #123", "Superseded by #123"
            // - "superseded: #123", "superceded: #123", "supersedes: #123"
            // - "supercedes#123" (without space)
            // - "replaces #123", "replaced by #123"
            // - Bullet points: "- supercedes #123"
            const matches = [...body.matchAll(regex)];

            const supersededPrs = matches.map(m => parseInt(m[1], 10));
            const uniquePrs = [...new Set(supersededPrs)].filter(pr => pr !== newPrNumber);

            console.log(`Found ${uniquePrs.length} superseded PRs: ${uniquePrs.join(', ')}`);

            core.setOutput('superseded_prs', JSON.stringify(uniquePrs));
            core.setOutput('new_pr_number', newPrNumber);
            core.setOutput('new_pr_title', newPrTitle);
            core.setOutput('new_pr_url', newPrUrl);

            return uniquePrs;

      - name: Checkout repository for template
        if: steps.parse.outputs.superseded_prs != '[]' && inputs.comment_template_path != ''
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Comment and close superseded PRs
        if: steps.parse.outputs.superseded_prs != '[]'
        uses: actions/github-script@v7
        env:
          SUPERSEDED_LABEL: ${{ inputs.superseded_label }}
          COMMENT_TEMPLATE_PATH: ${{ inputs.comment_template_path }}
          COMMENT_FOOTER: ${{ inputs.comment_footer }}
          MARK_DUPLICATE_COMMENT: ${{ inputs.mark_duplicate_comment }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const supersededPrs = JSON.parse('${{ steps.parse.outputs.superseded_prs }}');
            const newPrNumber = ${{ steps.parse.outputs.new_pr_number }};
            const newPrTitle = `${{ steps.parse.outputs.new_pr_title }}`;
            const newPrUrl = `${{ steps.parse.outputs.new_pr_url }}`;

            const supersededLabel = (process.env.SUPERSEDED_LABEL || '').trim();
            const templatePath = (process.env.COMMENT_TEMPLATE_PATH || '').trim();
            const commentFooter = (process.env.COMMENT_FOOTER || '').trim();
            const markDuplicate = ['true', '1', 'yes', 'y', 'on'].includes(
              (process.env.MARK_DUPLICATE_COMMENT || '').trim().toLowerCase(),
            );
            const footerBlock = commentFooter ? `\n---\n${commentFooter}` : '';

            for (const prNumber of supersededPrs) {
              try {
                // Check if PR is still open
                const { data: pr } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                });

                if (pr.state !== 'open') {
                  console.log(`PR #${prNumber} is already ${pr.state}, skipping`);
                  continue;
                }

                let baseComment;
                if (templatePath) {
                  const resolvedPath = path.resolve(process.env.GITHUB_WORKSPACE || process.cwd(), templatePath);
                  baseComment = fs.readFileSync(resolvedPath, 'utf8');
                } else {
                  baseComment = `## This PR has been superseded\n\n` +
                    `This pull request has been superseded by **#${newPrNumber}**.\n\n` +
                    `**New PR:** [${newPrTitle}](${newPrUrl})\n\n` +
                    `The work from this PR was carried forward into the new PR, so this PR is being closed automatically.`;
                }

                const replacements = {
                  '{{new_pr_number}}': newPrNumber,
                  '{{new_pr_title}}': newPrTitle,
                  '{{new_pr_url}}': newPrUrl,
                  '{{superseded_pr_number}}': prNumber,
                };

                let comment = baseComment;
                for (const [token, value] of Object.entries(replacements)) {
                  comment = comment.split(token).join(String(value));
                }

                comment = comment.trimEnd() + footerBlock;

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: comment,
                });

                console.log(`Added supersession comment to PR #${prNumber}`);

                if (markDuplicate) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    body: `Duplicate of #${newPrNumber}`,
                  });
                }

                // Close the PR
                await github.rest.pulls.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  state: 'closed',
                });

                console.log(`Closed PR #${prNumber}`);

                if (!supersededLabel) {
                  continue;
                }

                // Add a label to indicate it was superseded
                try {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    labels: [supersededLabel],
                  });
                } catch (labelError) {
                  // Label might not exist, that's OK
                  console.log(`Could not add '${supersededLabel}' label: ${labelError.message}`);
                }

              } catch (error) {
                console.error(`Error processing PR #${prNumber}: ${error.message}`);
              }
            }
